# 양의 정수만 주어지는 경우의 부분집합의 합 문제
# n 부분집합에 포함시킬지 고려하는 원소의 인덱스
# k 주어진 원소의 개수
# s n-1까지의 원소 중 부분집합에 포함된 원소의 합
# m 찾고자 하는 부분집합의 합


def f(n, k, s, m):
    global cnt
    global cnt2 # 재귀 호출의 횟수 기록
    cnt2 += 1
    if n == k: # 하나의 부분집합이 완성된 경우
        if s == m:  # 현재까지의 부분집합의 합이 찾고자 하는 합과 같은 경우
            cnt += 1  # 이후의 어떤 원소를 선택해도 10보다 크다
        return
    else: # 고려할 원소가 남아있는 경우
        f(n+1, k, s+a[n], m) # 부분집합에 포함시키는 경우
        f(n+1, k, s, m) # n번 원소를 부분집합에 포함시키지 않는 경우


def f(n, k, s, m):
    global cnt
    global cnt2 # 재귀 호출의 횟수 기록
    cnt2 += 1
    if s == m:  # 현재까지의 부분집합의 합이 찾고자 하는 합과 같은 경우
        cnt += 1 # 이후의 어떤 원소를 선택해도 10보다 크다
    elif n == k: # 하나의 부분집합이 완성된 경우
        return
    else: # 고려할 원소가 남아있는 경우
        f(n+1, k, s+a[n], m) # 부분집합에 포함시키는 경우
        f(n+1, k, s, m) # n번 원소를 부분집합에 포함시키지 않는 경우


def f(n, k, s, m):
    global cnt
    global cnt2 # 재귀 호출의 횟수 기록
    cnt2 += 1
    if s == m:  # 현재까지의 부분집합의 합이 찾고자 하는 합과 같은 경우
        cnt += 1 # 이후의 어떤 원소를 선택해도 10보다 크다
    elif n == k: # 하나의 부분집합이 완성된 경우
        return
    elif s > m: # 부분집합의 합이 찾는 값보다 커진 경우도 중단
        return
    else: # 고려할 원소가 남아있는 경우
        f(n+1, k, s+a[n], m) # 부분집합에 포함시키는 경우
        f(n+1, k, s, m) # n번 원소를 부분집합에 포함시키지 않는 경우


def f(n, k, s, m, t):
    global cnt
    global cnt2 # 재귀 호출의 횟수 기록
    cnt2 += 1
    if s == m:  # 현재까지의 부분집합의 합이 찾고자 하는 합과 같은 경우
        cnt += 1 # 이후의 어떤 원소를 선택해도 10보다 크다
    elif n == k: # 하나의 부분집합이 완성된 경우
        return
    elif s > m: # 부분집합의 합이 찾는 값보다 커진 경우도 중단
        return
    elif s + t < m: # 남은 원소를 모두 더해도 찾는 값에 못미치는 경우
        return
    else: # 고려할 원소가 남아있는 경우
        f(n+1, k, s+a[n], m, t-a[n]) # 부분집합에 포함시키는 경우
        f(n+1, k, s, m, t-a[n]) # n번 원소를 부분집합에 포함시키지 않는 경우


a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cnt = 0
cnt2 = 0
# f(0, len(a), 0, 10)
f(0, len(a), 0, 53, sum(a))
print(cnt)
print(cnt2)